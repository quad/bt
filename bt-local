#!/usr/bin/env ruby

require 'andand'
require 'fileutils'
require 'tmpdir'
require 'trollop'
require 'yaml'

CONFIG = YAML.load(File.open("./.bt"))

def commit(name)
  `git rev-parse --verify #{name}`.strip
end

def done
  [].tap do |oks|
    `git show-branch --list bt/#{commit 'HEAD'}/*`.each_line do |branch_line|
      %r{ \[bt/(?<hash>[0-9a-f]+)/(?<stage>\w+)\] (?<status>OK|PASS|FAIL|NO) } =~ branch_line
      oks << stage if ['OK', 'PASS'].include? status
    end
  end
end

def stages
  # TODO: Enforce stages being politely named.
  Hash[`git ls-tree --name-only HEAD stages/`.split.map do |fn|
    [File.basename(fn), YAML.load(`git cat-file blob HEAD:#{fn}`)]
  end]
end

def stage(name)
  stages[name]
end

def ready
  dones = done

  [].tap do |readies|
    stages.each do |name, info|
      needs = info['needs'] ? info['needs'] - dones : []
      readies << name if needs.empty?
    end
  end - dones
end

def branch_name(ref, stage)
  # TODO: Unique identifier after the stage.
  "bt/#{commit ref}/#{stage}"
end

def go(stage_name)
  branch = branch_name('HEAD', stage_name)

  Dir.mktmpdir do |tmp_dir|
    system "git clone --recursive -- . #{tmp_dir}"

    FileUtils.cd(tmp_dir) do |build_dir|
      s = stage(stage_name)

      # Merge
      s['needs'].andand.each do |sn|
        system "git pull --squash origin #{branch_name 'HEAD', sn}"
      end
      system "git reset --mixed HEAD"

      # Build
      log = `#{s['run']} 2>&1`
      status = $?.exitstatus.zero? ? :PASS : :FAIL

      # Add files
      s['results'].andand.each { |fn| system "git add #{fn}" }
      IO.popen("git commit --author=\"#{CONFIG['bt']['author']}\" --allow-empty --cleanup=verbatim --file=-", "w+") do |pipe|
        pipe.puts "#{status.to_s} bt loves you"
        pipe.puts

        pipe << log
        pipe.close_write
      end
    end

    # Merge back
    system "git fetch #{tmp_dir} HEAD:#{branch}"
  end
end

SUB_COMMANDS = %w(ready go)
global_opts = Trollop::options do
  banner "build thing (local)"
  stop_on SUB_COMMANDS
end

command = ARGV.shift
command_opts = case command
               when "ready"
                 ready.each { |s| puts s }
               when "go"
                 stage = ready.first
                 Trollop::die "no stage to build" unless stage

                 go stage
               else
                 Trollop::die "unknown subcommand #{command.inspect}"
               end
